"""Densities"""

"""Unitful acceleration generated by an a P <: AbstractPotential"""
function density(pot::P, x::Vector{<:Unitful.Length}, t::T) where {P<:AbstractPotential, T<:Unitful.Time}
    x, t = adimensional(x, t)
    return density(pot, x, t)*𝕦.ρ
end
function density(pot::P, x::Vector{<:Unitful.Length}) where {P<:AbstractPotential}
    x = adimensional(x)
    return density(pot, x)*𝕦.ρ
end

"""
    density(pot::P, x::AbstractArray{L}, t::T) where {P<:AbstractStaticPotential, L<:Real, T<:Real}
Bridge function for static potentials
"""
function density(pot::P, x::AbstractArray{L}, t::T) where {P<:AbstractStaticPotential, L<:Real, T<:Real}
    return density(pot, x)
end

"""Density of a CompositePotential"""
function density(pot::CompositePotential, x::AbstractArray{L}, t::T=0.0) where {L<:Real, T<:Real}
    ρ = zero(L)
    for p ∈ pot
        ρ += density(p, x, t)
    end
    return ρ
end


"""List of specific densities"""

function density(pot::PowerLawCutoff, r::AbstractArray{L}) where {L<:Real}
    @unpack_PowerLawCutoff
# Galpy: return amp * pow(r,-alpha) * exp ( -r2 / rc / rc );
# Gala:      pars:
    #         0 - G (Gravitational constant)
    #         1 - m (total mass)
    #         2 - a (power-law index)
    #         3 - c (cutoff radius)
    # */
    # double r, A;
    # r = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2]);
    # A = pars[1] / (2*M_PI) * pow(pars[3], pars[2] - 3) / gsl_sf_gamma(0.5 * (3 - pars[2]));
    # return A * pow(r, -pars[2]) * exp(-r*r / (pars[3]*pars[3]));
    r = sqrt( dot(x,x) )
    A = (m/2π)*c^(α-3)/gamma(0.5*(3-α))
    return A*r^(-α)*exp(-(r/c)^2)
end