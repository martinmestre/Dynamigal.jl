"""Accelerations"""


"""
-------------------------------------------------------------------------------

Accelerations generated by a certain entity on a given 3D position x at time t.

--------------------------------------------------------------------------------
"""


"""Acceleration generated by single potential. Static and time-dependent method."""
function acceleration(pot::P, x::AbstractVector{L}, t::T) where {P<:AbstractPotential, L<:Real, T<:Real}
    return -gradient(y->potential(pot, y, t), x)[1]
end
function acceleration(pot::P, x::AbstractVector{L}) where {P<:AbstractPotential, L<:Real}
    return -gradient(y->potential(pot, y), x)[1]
end
"""For testing potential with defined acceleration"""
function acceleration(::AutoDiffTrait, pot::P, x::AbstractVector{L}) where {P<:AbstractPotential, L<:Real}
    return -gradient(y->potential(pot, y), x)[1]
end
"""
    acceleration(pot::P, x::AbstractVector{L}, t::T) where {P<:AbstractStaticPotential, L<:Real, T<:Real}
Bridge function for static potentials
"""
function acceleration(pot::P, x::AbstractVector{L}, t::T) where {P<:AbstractStaticPotential, L<:Real, T<:Real}
    return acceleration(pot, x)
end

"""Acceleration generated by a spherical static potential"""
function acceleration(pot::P, x::AbstractVector{T}) where {P<:AbstractSphericalStaticPotential, T<:Real}
    r = sqrt( dot(x,x) )
    return -G*mass(pot, r)*x/r^3
end

"""Acceleration generated by a CompositePotential"""
function acceleration(pot::CompositePotential, x::AbstractVector{L}, t::T=0.0) where {L<:Real, T<:Real}
    sum_acc = zeros(L, 3)
    for p âˆˆ pot
        sum_acc .+= acceleration(p, x, t)
    end
    return sum_acc
end

"""Unitful acceleration generated by an a P <: AbstractPotential"""
function acceleration(pot::P, x::Vector{<:Unitful.Length}, t::T) where {P<:AbstractPotential, T<:Unitful.Time}
    x, t = adimensional(x, t)
    return acceleration(pot, x, t)*ð•¦.a
end
function acceleration(pot::P, x::Vector{<:Unitful.Length}) where {P<:AbstractPotential}
    x = adimensional(x)
    return acceleration(pot, x)*ð•¦.a
end


"""Acceleration generated by a P <: AbstractMacroParticle: reduces to its potential (single or composite)
âš  Warning: acceleration should depend on the difference (Î”x) between the position x and the position of the potential source (y). See alternative method below.
"""
function acceleration(mp::P, Î”x::AbstractVector{L}, t::T=0.0) where {P<:AbstractMacroParticle, L<:Real, T<:Real}
    return acceleration(mp.pot, Î”x, t)
end

"""Acceleration generated by a P <: AbstractMacroParticle: reduces to its potential (single or composite)
âš  Warning: acceleration should depend on the difference between the position (x) and the position of the potential source (y). See alternative method above.
"""
function acceleration(mp::P, y::AbstractVector{L}, x::AbstractVector{L}, t::T=0.0) where {P<:AbstractMacroParticle, L<:Real, T<:Real}
    return acceleration(mp.pot, x-y, t)
end

"""
Acceleration generated by a P <: AbstractMacroParticleSystem
âš  Warning: acceleration should depend on the difference (Î”x) between the position x and the position of the potential sources (y).
length(y) == 3*length(mps)
"""
function acceleration(mps::P, y::AbstractVector{L}, x::AbstractVector{L}, t::T=0.0) where {P<:AbstractMacroParticleSystem, L<:Real, T<:Real}
    n = length(mps)
    acc = zero(MVector{3,L})
    for j âˆˆ 1:n
        Î”x = SVector{3}(x[1]-y[3j-2], x[2]-y[3j-1], x[3]-y[3j])
        acc .+= acceleration(mps[j].pot, Î”x, t)
    end
    return acc
end

"""
Acceleration generated by a D <: AbstractDiscreteDistribution onto an E <: AbstractEvent
âš  Warning: acceleration should depend on the difference (Î”x) between the position event.x and
the position of the potential sources (y).
length(y) == 3*length(dist)
"""
function acceleration(dist::D, y::AbstractVector{L}, event::E) where {D<:AbstractDiscreteDistribution, L<:Real, E<:AbstractEvent}
    return acceleration(dist, event.x-y, event.t)
end

"""Acceleration generated by D <: AbstractDiscreteDistribution a onto a P<:AbstractParticle
âš  Warning: acceleration should depend on the difference (Î”x) between the position p.event.x and
the position of the potential sources (y).
length(y) == 3*length(dist)
"""
function acceleration(dist::D, y::AbstractVector{L}, p::P) where {D<:AbstractDiscreteDistribution, L<:Real, P<:AbstractParticle}
    return acceleration(dist, y, p.event)
end




"""Acceleration generated by a P <: AbstractPotential when there is presence of dynamical friction
drag force.
The algorithm for the drag is dispatched according to the ð•— struct.
âš  Warning: here x and v are difference vectors between the perturber and the potential source.
"""
function acceleration(fric::F, p::P, x::AbstractVector{L}, v::AbstractVector{L}, t::T) where {P<:AbstractPotential, L<:Real, T<:Real, F<:AbstractFriction}
    return acceleration(p, x, t) + drag(fric, p, x, v, t)
end



"""Analytical accelerations"""

"""Allen and Santillan (generalized) halo"""

"""Hernquist potential"""

"""Kepler potential"""

"""MiyamotoNagaiDisk"""
function acceleration(pot::MiyamotoNagaiDisk, x::AbstractVector{T}) where {T<:Real}
    @unpack_MiyamotoNagaiDisk pot
    y = @view x[1:2]
    bz = sqrt(b*b + x[3]*x[3])
    abz = a + bz
    fac = -G*m / (dot(y,y) + abz*abz)^(1.5)
    return fac*SVector{3,T}(x[1], x[2], x[3]*abz/bz)
end


"""NFW halo acceleration"""
function acceleration(pot::NFW, x::AbstractVector{T}) where {T<:Real}
    r = sqrt( dot(x,x) )
    return -G*pot.m*f_nfw(r/pot.a)*x/r^3
end

"""Oscillatory Kepler dependent"""

"""Plummer"""

"""PowerLawCutoff"""
function acceleration(pot::PowerLawCutoff, x::AbstractVector{L}) where {L<:Real}
    @unpack m, c, Î² =  pot
    r = sqrt( dot(x,x) )
    return -G * m * (gamma_inc(Î², r*r/(c*c),0)[1]) * x / r^3
end

"""
------------------------------------------------------------------------------------

Accelerations received by each MacroParticle of a system at time t (mutating cache in some
of the methods below but not in specific ones, i.e. Clouds+MW, Sagittarius+Clouds+MW, etc.).

This are the accelerations needed by the ode(...).
cache acceleration is modified in-place, but not used by the ode(...).
I will have an alternative ode!(...) function that doesn't call any acceleration!(...).
------------------------------------------------------------------------------------
Two algorithms:
acceleration_c! and acceleration!

Example benchmark from testset AccelerationsMacroParticleSystem:

BenchmarkTools.Trial: 100 samples with 1 evaluation per sample.
 Range (min â€¦ max):  24.056 Î¼s â€¦ 58.068 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     24.424 Î¼s              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   25.954 Î¼s Â±  5.371 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–ˆâ–…
  â–ˆâ–ˆâ–ˆâ–†â–â–â–â–„â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–„â–†â–â–â–â–†â–â–â–â–â–„â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–„ â–„
  24.1 Î¼s      Histogram: log(frequency) by time      51.5 Î¼s <

 Memory estimate: 14.94 KiB, allocs estimate: 373.

BenchmarkTools.Trial: 100 samples with 1 evaluation per sample.
 Range (min â€¦ max):  37.776 Î¼s â€¦ 91.976 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     38.600 Î¼s              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   39.977 Î¼s Â±  7.462 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–ˆâ–…â–‚
  â–ˆâ–ˆâ–ˆâ–ˆâ–†â–â–â–â–â–â–„â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–„ â–„
  37.8 Î¼s      Histogram: log(frequency) by time      90.5 Î¼s <

 Memory estimate: 20.86 KiB, allocs estimate: 458.

Conclusion: acceleration! is more performant than acceleration_c!
"""

selec(i::I) where {I<:Integer} = 1+3(i-1)
"""Complement function to be used in acceleration computation"""
function complement(mps::P, x::AbstractVector{L}, i::I) where {P<:AbstractMacroParticleSystem, L<:Real, I<:Integer}
    n = length(mps)
    Ï = [mps[j].pot for j in 1:n if j != i]
    Ï‡ = [SVector{3,L}(
            x[selec(j)],
            x[selec(j)+1],
            x[selec(j)+2]
        ) for j in 1:n if j != i]
    return Ï, Ï‡
end
"""Acceleration of a system of macro particles using complement"""
function acceleration_c!(mps::P, x::AbstractVector{L}, t::T=0.0) where {P<:AbstractMacroParticleSystem,L<:Real, T<:Real}
    acc = mps.accelerations
    for i âˆˆ eachindex(mps)
        y = SVector{3,L}(x[selec(i)], x[selec(i)+1], x[selec(i)+2])
        Ï, Ï‡ = complement(mps, x, i)
        acc_sum = zero(SVector{3,L})
        for j in eachindex(Ï)
            Î”x = y - Ï‡[j]
            acc_sum += acceleration(Ï[j], Î”x, t)
        end
        acc[3i-2] = acc_sum[1]
        acc[3i-1] = acc_sum[2]
        acc[3i]   = acc_sum[3]
    end
    return acc
end

"""Acceleration of a system of macro particles without using complement"""
function acceleration!(mps::P, x::AbstractVector{L}, t::T=0.0) where {P<:AbstractMacroParticleSystem,L<:Real, T<:Real}
    n = length(mps)
    acc  = mps.accelerations
    @inbounds for i âˆˆ 1:n
        y = SVector{3,L}(x[3i-2], x[3i-1], x[3i])
        acc_sum = zero(MVector{3,L})
        for j âˆˆ 1:n
            i == j && continue
            Ï‡ = SVector{3,L}(x[3j-2], x[3j-1], x[3j])
            acc_sum .+= acceleration(mps[j].pot, y - Ï‡, t)
        end
        acc[3i-2] = acc_sum[1]
        acc[3i-1] = acc_sum[2]
        acc[3i]   = acc_sum[3]
    end

    return acc
end


"""Acceleration for LargeCloudMW system without friction"""
function acceleration(system::LargeCloudMW, u::AbstractVector{L}, t::T=0.0) where {L<:Real, T<:Real}
    @unpack mw, cloud = system
    Î”x = SVector{3,L}(u[4]-u[1], u[5]-u[2], u[6]-u[3])
    acc_at_cloud = acceleration(mw.pot, Î”x, t)
    acc_at_mw = acceleration(cloud.pot, -Î”x, t)
    return SVector{6,L}(acc_at_mw[1], acc_at_mw[2], acc_at_mw[3],
             acc_at_cloud[1], acc_at_cloud[2], acc_at_cloud[3])
end

#aca estoy...
"""Acceleration for LargeCloudMW system with dynamical friction"""
function acceleration(fric::F, system::LargeCloudMW, u::AbstractVector{L}, t::T=0.0) where { F<:AbstractFriction, L<:Real, T<:Real}
    @unpack mw, cloud = system
    Î”x = SVector{3,L}(u[4]-u[1], u[5]-u[2], u[6]-u[3])
    Î”v = SVector{3,L}(u[10]-u[7], u[11]-u[8], u[12]-u[9])
    acc_at_cloud = acceleration(fric, mw.pot, Î”x, Î”v, t)
    acc_at_mw = acceleration(cloud.pot, -Î”x, t)
    return SVector{6,L}(acc_at_mw[1], acc_at_mw[2], acc_at_mw[3],
             acc_at_cloud[1], acc_at_cloud[2], acc_at_cloud[3])
end
