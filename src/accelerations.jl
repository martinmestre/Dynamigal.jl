"""Accelerations"""


"""
-------------------------------------------------------------------------------

Accelerations generated by a certain entity on a given 3D position x at time t.

--------------------------------------------------------------------------------
"""


"""Acceleration generated by single potential. Static and time-dependent method."""
function acceleration(pot::P, x::AbstractArray{L}, t::T) where {P<:AbstractPotential, L<:Real, T<:Real}
    return -gradient(y->potential(pot, y, t), x)[1]
end
function acceleration(pot::P, x::AbstractArray{L}) where {P<:AbstractPotential, L<:Real}
    return -gradient(y->potential(pot, y), x)[1]
end

"""
    acceleration(pot::P, x::AbstractArray{L}, t::T) where {P<:AbstractStaticPotential, L<:Real, T<:Real}
Bridge function for static potentials
"""
function acceleration(pot::P, x::AbstractArray{L}, t::T) where {P<:AbstractStaticPotential, L<:Real, T<:Real}
    return acceleration(pot, x)
end

"""Acceleration generated by a CompositePotential"""
function acceleration(pot::CompositePotential, x::AbstractArray{L}, t::T=0.0) where {L<:Real, T<:Real}
    sum_acc = zeros(L, 3)
    for p ∈ pot
        sum_acc .+= acceleration(p, x, t)
    end
    return sum_acc
end

"""Unitful acceleration generated by an a P <: AbstractPotential"""
function acceleration(pot::P, x::Vector{<:Unitful.Length}, t::T) where {P<:AbstractPotential, T<:Unitful.Time}
    x, t = adimensional(x, t)
    return acceleration(pot, x, t)*𝕦.a
end
function acceleration(pot::P, x::Vector{<:Unitful.Length}) where {P<:AbstractPotential}
    x = adimensional(x)
    return acceleration(pot, x)*𝕦.a
end


"""Acceleration generated by a P <: AbstractMacroParticle: reduces to its potential (single or composite)
⚠ Warning: acceleration should depend on the difference (Δx) between the position x and the position of the potential source (y). See alternative method below.
"""
function acceleration(mp::P, Δx::AbstractArray{L}, t::T=0.0) where {P<:AbstractMacroParticle, L<:Real, T<:Real}
    return acceleration(mp.pot, Δx, t)
end

"""Acceleration generated by a P <: AbstractMacroParticle: reduces to its potential (single or composite)
⚠ Warning: acceleration should depend on the difference between the position (x) and the position of the potential source (y). See alternative method above.
"""
function acceleration(mp::P, y::AbstractArray{L}, x::AbstractArray{L}, t::T=0.0) where {P<:AbstractMacroParticle, L<:Real, T<:Real}
    return acceleration(mp.pot, x-y, t)
end

"""
Acceleration generated by a P <: AbstractMacroParticleSystem
⚠ Warning: acceleration should depend on the difference (Δx) between the position x and the position of the potential sources (y).
length(y) == 3*length(mps)
"""
function acceleration(mps::P, y::AbstractArray{L}, x::AbstractArray{L}, t::T=0.0) where {P<:AbstractMacroParticleSystem, L<:Real, T<:Real}
    n = length(mps)
    acc = zero(MVector{3,L})
    for j ∈ 1:n
        Δx = SVector{3}(x[1]-y[3j-2], x[2]-y[3j-1], x[3]-y[3j])
        acc .+= acceleration(mps[j].pot, Δx, t)
    end
    return acc
end

"""
Acceleration generated by a D <: AbstractDiscreteDistribution onto an E <: AbstractEvent
⚠ Warning: acceleration should depend on the difference (Δx) between the position event.x and
the position of the potential sources (y).
length(y) == 3*length(dist)
"""
function acceleration(dist::D, y::AbstractArray{L}, event::E) where {D<:AbstractDiscreteDistribution, L<:Real, E<:AbstractEvent}
    return acceleration(dist, event.x-y, event.t)
end

"""Acceleration generated by D <: AbstractDiscreteDistribution a onto a P<:AbstractParticle
⚠ Warning: acceleration should depend on the difference (Δx) between the position p.event.x and
the position of the potential sources (y).
length(y) == 3*length(dist)
"""
function acceleration(dist::D, y::AbstractArray{L}, p::P) where {D<:AbstractDiscreteDistribution, L<:Real, P<:AbstractParticle}
    return acceleration(dist, y, p.event)
end




"""Acceleration generated by a P <: AbstractPotential when there is presence of dynamical friction
drag force.
The algorithm for the drag is dispatched according to the 𝕗 struct.
⚠ Warning: here x and v are difference vectors between the perturber and the potential source.
"""
function acceleration(𝕗::F, p::P, x::AbstractArray{L}, v::AbstractArray{L}, t::T) where {P<:AbstractPotential, L<:Real, T<:Real, F<:AbstractFriction}
    return acceleration(p, x, t) + drag(𝕗, p, x, v, t)
end



"""Analytical accelerations"""

"""NFW halo acceleration"""
function acceleration(pot::NFW, x::AbstractArray{T}, t::T=0.0) where {T<:Real}
    @unpack m, a, 𝔸 = pot
    r = sqrt(x'x)
    𝕗 = -G*m/𝔸*f_nfw(r/a)/r^2
    return 𝕗*x/r
end


"""
------------------------------------------------------------------------------------

Accelerations received by each MacroParticle of a system at time t (mutating cache in some
of the methods below but not in specific ones, i.e. Clouds+MW, Sagittarius+Clouds+MW, etc.).

This are the accelerations needed by the ode(...).
cache acceleration is modified in-place, but not used by the ode(...).
I will have an alternative ode!(...) function that doesn't call any acceleration!(...).
------------------------------------------------------------------------------------
Two algorithms:
acceleration_c! and acceleration!

Example benchmark from testset AccelerationsMacroParticleSystem:

BenchmarkTools.Trial: 100 samples with 1 evaluation per sample.
 Range (min … max):  24.056 μs … 58.068 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     24.424 μs              ┊ GC (median):    0.00%
 Time  (mean ± σ):   25.954 μs ±  5.371 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

  █▅
  ███▆▁▁▁▄▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▄▆▁▁▁▆▁▁▁▁▄▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▄ ▄
  24.1 μs      Histogram: log(frequency) by time      51.5 μs <

 Memory estimate: 14.94 KiB, allocs estimate: 373.

BenchmarkTools.Trial: 100 samples with 1 evaluation per sample.
 Range (min … max):  37.776 μs … 91.976 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     38.600 μs              ┊ GC (median):    0.00%
 Time  (mean ± σ):   39.977 μs ±  7.462 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

  █▅▂
  ████▆▁▁▁▁▁▄▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▄ ▄
  37.8 μs      Histogram: log(frequency) by time      90.5 μs <

 Memory estimate: 20.86 KiB, allocs estimate: 458.

Conclusion: acceleration! is more performant than acceleration_c!
"""

selec(i::I) where {I<:Integer} = 1+3(i-1)
"""Complement function to be used in acceleration computation"""
function complement(mps::P, x::AbstractArray{L}, i::I) where {P<:AbstractMacroParticleSystem, L<:Real, I<:Integer}
    n = length(mps)
    ρ = [mps[j].pot for j in 1:n if j != i]
    χ = [SVector{3,L}(
            x[selec(j)],
            x[selec(j)+1],
            x[selec(j)+2]
        ) for j in 1:n if j != i]
    return ρ, χ
end
"""Acceleration of a system of macro particles using complement"""
function acceleration_c!(mps::P, x::AbstractArray{L}, t::T=0.0) where {P<:AbstractMacroParticleSystem,L<:Real, T<:Real}
    acc = mps.accelerations
    for i ∈ eachindex(mps)
        y = SVector{3,L}(x[selec(i)], x[selec(i)+1], x[selec(i)+2])
        ρ, χ = complement(mps, x, i)
        acc_sum = zero(SVector{3,L})
        for j in eachindex(ρ)
            Δx = y - χ[j]
            acc_sum += acceleration(ρ[j], Δx, t)
        end
        acc[3i-2] = acc_sum[1]
        acc[3i-1] = acc_sum[2]
        acc[3i]   = acc_sum[3]
    end
    return acc
end

"""Acceleration of a system of macro particles without using complement"""
function acceleration!(mps::P, x::AbstractVector{L}, t::T=0.0) where {P<:AbstractMacroParticleSystem,L<:Real, T<:Real}
    n = length(mps)
    acc  = mps.accelerations
    @inbounds for i ∈ 1:n
        y = SVector{3,L}(x[3i-2], x[3i-1], x[3i])
        acc_sum = zero(MVector{3,L})
        for j ∈ 1:n
            i == j && continue
            χ = SVector{3,L}(x[3j-2], x[3j-1], x[3j])
            acc_sum .+= acceleration(mps[j].pot, y - χ, t)
        end
        acc[3i-2] = acc_sum[1]
        acc[3i-1] = acc_sum[2]
        acc[3i]   = acc_sum[3]
    end

    return acc
end

# """Acceleration of an AbstractGalacticSystem, main method"""
# function acceleration(system::P, u::AbstractVector{L}, t::T=0.0) where {P<:AbstractGalacticSystem, L<:Real, T<:Real}
#     return acceleration(FrictionTrait(P), system, u, t)
# end

"""Acceleration for LargeCloudMW system without friction"""
function acceleration(system::LargeCloudMW, u::AbstractVector{L}, t::T=0.0) where {L<:Real, T<:Real}
    @unpack mw, cloud = system
    Δx = SVector{3,L}(u[4]-u[1], u[5]-u[2], u[6]-u[3])
    acc_at_cloud = acceleration(mw.pot, Δx, t)
    acc_at_mw = acceleration(cloud.pot, -Δx, t)
    return SVector{6,L}(acc_at_mw[1], acc_at_mw[2], acc_at_mw[3],
             acc_at_cloud[1], acc_at_cloud[2], acc_at_cloud[3])
end

#aca estoy...
"""Acceleration for LargeCloudMW system with dynamical friction"""
function acceleration(𝕗::F, system::LargeCloudMW, u::AbstractVector{L}, t::T=0.0) where { F<:AbstractFriction, L<:Real, T<:Real}
    @unpack mw, cloud = system
    Δx = SVector{3,L}(u[4]-u[1], u[5]-u[2], u[6]-u[3])
    Δv = SVector{3,L}(u[10]-u[7], u[11]-u[8], u[12]-u[9])
    acc_at_cloud = acceleration(𝕗, mw.pot, Δx, Δv, t)
    acc_at_mw = acceleration(cloud.pot, -Δx, t)
    return SVector{6,L}(acc_at_mw[1], acc_at_mw[2], acc_at_mw[3],
             acc_at_cloud[1], acc_at_cloud[2], acc_at_cloud[3])
end
