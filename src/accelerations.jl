"""Accelerations"""


"""
-------------------------------------------------------------------------------

Accelerations generated by a certain entity on a given 3D position x at time t.

--------------------------------------------------------------------------------
"""


"""Acceleration generated by single potential. Static and time-dependent method."""
function acceleration(pot::P, x::AbstractArray{L}, t::T) where {P<:AbstractPotential, L<:Real, T<:Real}
    return -gradient(y->potential(pot, y, t), x)[1]
end
function acceleration(pot::P, x::AbstractArray{L}) where {P<:AbstractPotential, L<:Real}
    return -gradient(y->potential(pot, y), x)[1]
end

"""
    acceleration(pot::P, x::AbstractArray{L}, t::T) where {P<:AbstractStaticPotential, L<:Real, T<:Real}
Bridge function for static potentials
"""
function acceleration(pot::P, x::AbstractArray{L}, t::T) where {P<:AbstractStaticPotential, L<:Real, T<:Real}
    return acceleration(pot, x)
end

"""Acceleration generated by a CompositePotential"""
function acceleration(pot::CompositePotential, x::AbstractArray{L}, t::T=0.0) where {L<:Real, T<:Real}
    sum_acc = zeros(L, 3)
    for p âˆˆ pot
        sum_acc .+= acceleration(p, x, t)
    end
    return sum_acc
end

"""Unitful acceleration generated by an a P <: AbstractPotential"""
function acceleration(pot::P, x::Vector{<:Unitful.Length}, t::T) where {P<:AbstractPotential, T<:Unitful.Time}
    x, t = adimensional(x, t)
    return acceleration(pot, x, t)*ð•¦.a
end
function acceleration(pot::P, x::Vector{<:Unitful.Length}) where {P<:AbstractPotential}
    x = adimensional(x)
    return acceleration(pot, x)*ð•¦.a
end


"""Acceleration generated by a P <: AbstractMacroParticle: reduces to its potential (single or composite)"""
function acceleration(mp::P, x::AbstractArray{L}, t::T=0.0) where {P<:AbstractMacroParticle, L<:Real, T<:Real}
    return acceleration(mp.pot, x, t)
end

"""Acceleration generated by a P <: AbstractMacroParticleSystem"""
function acceleration(mps::P, x::AbstractArray{L}, t::T=0.0) where {P<:AbstractMacroParticleSystem, L<:Real, T<:Real}
    sum_acc = zeros(L, 3)
    for mp âˆˆ mps
        sum_acc .+= acceleration(mp, x, t)
    end
    return sum_acc
end

"""Acceleration generated by a C <: AbstractCosmos onto an E <: AbstractEvent"""
function acceleration(mp::C, event::E) where {C<:AbstractCosmos, E<:AbstractEvent}
    return acceleration(mp, event.x, event.t)
end

"""Acceleration generated by a C <: AbstractCosmos onto a TestParticle, Particle, and MacroParticle"""
function acceleration(mp::C, p::TestParticle) where {C<:AbstractCosmos}
    return acceleration(mp, p.event)
end
function acceleration(mp::C, p::Particle) where {C<:AbstractCosmos}
    return acceleration(mp, p.event)
end
function acceleration(mp::C, p::MacroParticle) where {C<:AbstractCosmos}
    return acceleration(mp, p.event)
end

"""Analytical accelerations"""

"""NFW halo acceleration"""
function acceleration(pot::NFW, x::AbstractArray{T}, t::T=0.0) where {T<:Real}
    @unpack m, a, ð”¸ = pot
    r = sqrt(x'x)
    ð•— = -G*m/ð”¸*f_nfw(r/a)/r^2
    return ð•—*x/r
end


"""
------------------------------------------------------------------------------------

Accelerations received by each MacroParticle of a system at time t (mutating cache).

This are the accelerations needed by the ode(...).
cache acceleration is modified in-place, but not used by the ode(...).
I will have an alternative ode!(...) function that doesn't call any acceleration!(...).
------------------------------------------------------------------------------------
Two algorithms:
acceleration_c! and acceleration!

Example benchmark from testset AccelerationsMacroParticleSystem:

BenchmarkTools.Trial: 100 samples with 1 evaluation per sample.
 Range (min â€¦ max):  24.056 Î¼s â€¦ 58.068 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     24.424 Î¼s              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   25.954 Î¼s Â±  5.371 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–ˆâ–…
  â–ˆâ–ˆâ–ˆâ–†â–â–â–â–„â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–„â–†â–â–â–â–†â–â–â–â–â–„â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–„ â–„
  24.1 Î¼s      Histogram: log(frequency) by time      51.5 Î¼s <

 Memory estimate: 14.94 KiB, allocs estimate: 373.

BenchmarkTools.Trial: 100 samples with 1 evaluation per sample.
 Range (min â€¦ max):  37.776 Î¼s â€¦ 91.976 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     38.600 Î¼s              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   39.977 Î¼s Â±  7.462 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–ˆâ–…â–‚
  â–ˆâ–ˆâ–ˆâ–ˆâ–†â–â–â–â–â–â–„â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–„ â–„
  37.8 Î¼s      Histogram: log(frequency) by time      90.5 Î¼s <

 Memory estimate: 20.86 KiB, allocs estimate: 458.

Conclusion: acceleration! is more performant than acceleration_c!
"""

selec(i::I) where {I<:Integer} = 1+3(i-1)
"""Complement function to be used in acceleration computation"""
function complement(mps::P, x::AbstractArray{L}, i::I) where {P<:AbstractMacroParticleSystem, L<:Real, I<:Integer}
    n = length(mps)
    Ï = [mps[j].pot for j in 1:n if j != i]
    Ï‡ = [SVector{3,L}(
            x[selec(j)],
            x[selec(j)+1],
            x[selec(j)+2]
        ) for j in 1:n if j != i]
    return Ï, Ï‡
end
"""Acceleration of a system of macro particles using complement"""
function acceleration_c!(mps::P, x::AbstractArray{L}, t::T=0.0) where {P<:AbstractMacroParticleSystem,L<:Real, T<:Real}
    acc = mps.accelerations
    for i âˆˆ eachindex(mps)
        y = SVector{3,L}(x[selec(i)], x[selec(i)+1], x[selec(i)+2])
        Ï, Ï‡ = complement(mps, x, i)
        acc_sum = zero(SVector{3,L})
        for j in eachindex(Ï)
            Î”x = y - Ï‡[j]
            acc_sum += acceleration(Ï[j], Î”x, t)
        end
        acc[3i-2] = acc_sum[1]
        acc[3i-1] = acc_sum[2]
        acc[3i]   = acc_sum[3]
    end
    return acc
end

"""Acceleration of a system of macro particles without using complement"""
function acceleration!(mps::P, x::AbstractVector{L}, t::T=0.0) where {P<:AbstractMacroParticleSystem,L<:Real, T<:Real}
    n = length(mps)
    acc  = mps.accelerations
    @inbounds for i âˆˆ 1:n
        y = SVector{3,L}(x[3i-2], x[3i-1], x[3i])
        acc_sum = zero(MVector{3,L})
        for j âˆˆ 1:n
            i == j && continue
            Ï‡ = SVector{3}(x[3j-2], x[3j-1], x[3j])
            acc_sum .+= acceleration(mps[j].pot, y - Ï‡, t)
        end
        acc[3i-2] = acc_sum[1]
        acc[3i-1] = acc_sum[2]
        acc[3i]   = acc_sum[3]
    end

    return acc
end



