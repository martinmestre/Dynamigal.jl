"""Accelerations"""


"""
-------------------------------------------------------------------------------

Accelerations generated by a certain entity on a given 3D position x at time t.

--------------------------------------------------------------------------------
"""


"""Acceleration generated by single potential. Static and time-dependent method."""
function acceleration(pot::P, x::AbstractArray{L}, t::T) where {P<:AbstractPotential, L<:Real, T<:Real}
    return -gradient(y->potential(pot, y, t), x)[1]
end
function acceleration(pot::P, x::AbstractArray{L}) where {P<:AbstractPotential, L<:Real}
    return -gradient(y->potential(pot, y), x)[1]
end

"""
    acceleration(pot::P, x::AbstractArray{L}, t::T) where {P<:AbstractStaticPotential, L<:Real, T<:Real}
Bridge function for static potentials
"""
function acceleration(pot::P, x::AbstractArray{L}, t::T) where {P<:AbstractStaticPotential, L<:Real, T<:Real}
    return acceleration(pot, x)
end

"""Acceleration generated by a CompositePotential"""
function acceleration(pot::CompositePotential, x::AbstractArray{L}, t::T=0.0) where {L<:Real, T<:Real}
    sum_acc = zeros(L, 3)
    for p ∈ pot
        sum_acc .+= acceleration(p, x, t)
    end
    return sum_acc
end

"""Unitful acceleration generated by an a P <: AbstractPotential"""
function acceleration(pot::P, x::Vector{<:Unitful.Length}, t::T) where {P<:AbstractPotential, T<:Unitful.Time}
    x, t = adimensional(x, t)
    return acceleration(pot, x, t)*𝕦.a
end
function acceleration(pot::P, x::Vector{<:Unitful.Length}) where {P<:AbstractPotential}
    x = adimensional(x)
    return acceleration(pot, x)*𝕦.a
end


"""Acceleration generated by a P <: AbstractMacroParticle: reduces to its potential (single or composite)"""
function acceleration(mp::P, x::AbstractArray{L}, t::T=0.0) where {P<:AbstractMacroParticle, L<:Real, T<:Real}
    return acceleration(mp.pot, x, t)
end

"""Acceleration generated by a P <: AbstractMacroParticleSystem"""
function acceleration(mps::P, x::AbstractArray{L}, t::T=0.0) where {P<:AbstractMacroParticleSystem, L<:Real, T<:Real}
    sum_acc = zeros(L, 3)
    for mp ∈ mps
        sum_acc .+= acceleration(mp, x, t)
    end
    return sum_acc
end

"""Acceleration generated by a C <: AbstractCosmos onto an E <: AbstractEvent"""
function acceleration(mp::C, event::E) where {C<:AbstractCosmos, E<:AbstractEvent}
    return acceleration(mp, event.x, event.t)
end

"""Acceleration generated by a C <: AbstractCosmos onto a TestParticle, Particle, and MacroParticle"""
function acceleration(mp::C, p::TestParticle) where {C<:AbstractCosmos}
    return acceleration(mp, p.event)
end
function acceleration(mp::C, p::Particle) where {C<:AbstractCosmos}
    return acceleration(mp, p.event)
end
function acceleration(mp::C, p::MacroParticle) where {C<:AbstractCosmos}
    return acceleration(mp, p.event)
end

"""Analytical accelerations"""

"""NFW halo acceleration"""
function acceleration(pot::NFW, x::AbstractArray{T}, t::T=0.0) where {T<:Real}
    @unpack m, a, 𝔸 = pot
    r = sqrt(x'x)
    𝕗 = -G*m/𝔸*f_nfw(r/a)/r^2
    return 𝕗*x/r
end


"""
------------------------------------------------------------------------------------

Accelerations received by each MacroParticle of a system at time t (mutating cache).

This are the accelerations needed by the ode(...).
cache acceleration is modified in-place, but not used by the ode(...).
I will have an alternative ode!(...) function that doesn't call any acceleration!(...).
------------------------------------------------------------------------------------
Two algorithms:
"""

selec(i::I) where {I<:Integer} = 1+3(i-1)
"""Complement function to be used in acceleration computation"""
function complement(mps::P, x::AbstractArray{L}, i::I) where {P<:AbstractMacroParticleSystem, L<:Real, I<:Integer}
    n = length(mps)
    ρ = [mps[j].pot for j in 1:n if j != i]
    χ = [SVector{3,L}(
            x[selec(j)],
            x[selec(j)+1],
            x[selec(j)+2]
        ) for j in 1:n if j != i]
    return ρ, χ
end
"""Acceleration of a system of macro particles using complement"""
function acceleration_c!(mps::P, x::AbstractArray{L}, t::T=0.0) where {P<:AbstractMacroParticleSystem,L<:Real, T<:Real}
    acc = mps.accelerations
    for i ∈ eachindex(mps)
        y = SVector{3,L}(x[selec(i)], x[selec(i)+1], x[selec(i)+2])
        ρ, χ = complement(mps, x, i)
        acc_sum = zero(SVector{3,L})
        for j in eachindex(ρ)
            Δx = y - χ[j]
            acc_sum += acceleration(ρ[j], Δx, t)
        end
        acc[3i-2] = acc_sum[1]
        acc[3i-1] = acc_sum[2]
        acc[3i]   = acc_sum[3]
    end
    return acc
end

"""Acceleration of a system of macro particles without using complement"""
function acceleration!(mps::P, x::AbstractVector{L}, t::T=0.0) where {P<:AbstractMacroParticleSystem,L<:Real, T<:Real}
    n = length(mps)
    acc  = mps.accelerations
    @inbounds for i ∈ 1:n
        y = SVector{3,L}(x[3i-2], x[3i-1], x[3i])
        acc_sum = zero(MVector{3,L})
        for j ∈ 1:n
            i == j && continue
            χ = SVector{3}(x[3j-2], x[3j-1], x[3j])
            acc_sum .+= acceleration(mps[j].pot, y - χ, t)
        end
        acc[3i-2] = acc_sum[1]
        acc[3i-1] = acc_sum[2]
        acc[3i]   = acc_sum[3]
    end

    return acc
end



